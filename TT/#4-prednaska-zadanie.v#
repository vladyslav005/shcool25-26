(*********************************************)
(**       Zadanie k prednáške 4             **)
(*********************************************)

(*        Import potrebných knižníc         *) 

Require Import Stdlib.Bool.Bool.
Require Import Stdlib.Arith.PeanoNat.
Require Import Init.Nat.
Require Import Stdlib.Lists.List.
Import ListNotations.
Local Open Scope nat_scope.
Local Open Scope list_scope.

(*-------------------------------------------*)
(** Úlohy:                                   *)
(*-------------------------------------------*)


(** Úloha 1 ★  
    Dokážte, že z `even p = true` vyplýva `odd (S p) = true`.*)
Theorem silly_ex : forall p,
  (forall n, even n = true -> even (S n) = false) ->
  (forall n, even n = false -> odd n = true) ->
  even p = true ->
  odd (S p) = true.
Proof. 
  intros p Hstep Hodd Heven.
  apply Hodd.
  apply Hstep.
  exact Heven.
Qed.

Lemma x :
  forall (l : list nat),
    l ++ [] = l.
Proof.
  intros.
  induction l.
  simpl.
  reflexivity.
  simpl.
  rewrite IHl.
  reflexivity.
Qed.

Lemma append_assoc :
  forall (l1 l2 l3 : list nat),
    (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).
Proof.
  intros l1 l2 l3.
  induction l1 as [| x xs IH].
  - simpl. reflexivity.
  - simpl. rewrite IH. reflexivity.
Qed.


Lemma reverse_append :
  forall (l1 l2 : list nat),
    rev (app l1 l2) = app (rev l2) (rev l1).
Proof.
  intros l1 l2.
  induction l1 as [| x xs IH].
  - simpl. rewrite x. reflexivity.
  - simpl. rewrite IH.
    rewrite append_assoc.  (* associate (reverse l2 ++ reverse xs) ++ [x] *)
    reflexivity.
Qed.


Theorem reverse_invol : forall (l : list nat),
  Theorem new_theorem : .
Proof.

Qed.
rev (rev l) = l.
Proof.
  intros l.
  induction l as [| n l IHl].
  - simpl. reflexivity.
  - simpl.                           (* reverse (append (reverse l) [n]) *)
    rewrite reverse_append.          (* = append (reverse [n]) (reverse (reverse l)) *)
    simpl.                           (* reverse [n] = [n] *)
    rewrite IHl.
    reflexivity.
Qed.

(** Úloha 2 ★  
    Dokážte, že ak `l = rev l'`, potom aj `l' = rev l`. *)
Theorem rev_exercise1 : forall (l l' : list nat),
  l = rev l' -> l' = rev l.
Proof. 
  intros.
  rewrite H.
  rewrite reverse_invol.
  reflexivity.
Qed.


(** Úloha 3 ★  
    Dokážte, že z dvoch rovností zoznamov vyplýva `x = y`. *)
Example injection_ex3 : forall (X : Type) (x y z : X) (l j : list X),
  x :: y :: l = z :: j ->
  j = z :: l ->
  x = y.
Proof. 
  intros .
  subst j.
  injection H as Htl Hxz.
  rewrite Htl .
  rewrite Hxz.
  reflexivity.
Qed.


(** Úloha 4 ★  
    Dokážte, že zoznam `x :: y :: l` sa nemôže rovnať prázdnemu zoznamu. *)
Example discriminate_ex3 :
  forall (X : Type) (x y z : X) (l j : list X),
    x :: y :: l = [] ->
    x = z.
Proof. 
  intros.
  discriminate.
Qed.


(** Úloha 5 ★  
    Dokážte, že ak `n =? m = true`, potom `n = m`. *)
Theorem eqb_true : forall n m,
  n =? m = true -> n = m.
Proof. Admitted.


(** Úloha 6 ★  
    Dokážte, že ak `n + n = m + m`, potom `n = m`. *)
Theorem plus_n_n_injective : forall n m,
  n + n = m + m ->
  n = m.
Proof. Admitted.


(** Úloha 7 ★  
    Dokážte, že ak `length l = n`, potom `nth_error l n = None`. *)
Theorem nth_error_after_last: forall (n : nat) (X : Type) (l : list X),
  length l = n ->
  nth_error l n = None.
Proof. Admitted.


(** Úloha 8 ★  
    Dokážte, že pre ľubovoľnú booleovskú funkciu `f` platí `f (f (f b)) = f b`. *)
Theorem bool_fn_applied_thrice :
  forall (f : bool -> bool) (b : bool),
  f (f (f b)) = f b.
Proof. Admitted.


(** Úloha 9 ★  
    Dokážte symetriu `eqb`: `(n =? m) = (m =? n)`. *)
Theorem eqb_sym : forall (n m : nat),
  (n =? m) = (m =? n).
Proof. Admitted.


(** Úloha 10 ★  
    Dokážte tranzitivitu `eqb`: ak `n =? m = true` a `m =? p = true`,
    potom `n =? p = true`. *)
Theorem eqb_trans : forall n m p,
  n =? m = true ->
  m =? p = true ->
  n =? p = true.
Proof. Admitted.


(** Úloha 11 ★  
    Dokážte, že ak `filter test l = x :: lf`, tak `test x = true`. *)
Theorem filter_exercise : forall (X : Type) (test : X -> bool)
                                 (x : X) (l lf : list X),
  filter test l = x :: lf ->
  test x = true.
Proof. Admitted.


(** Úloha 12 ★  
    Dokážte, že ak `n + m = 0`, potom `n = 0` a `m = 0`. *)
Example plus_is_O :
  forall n m : nat, n + m = 0 -> n = 0 /\ m = 0.
Proof. Admitted.


(** Úloha 13 ★  
    Dokážte komutatívnosť konjunkcie: `P /\ Q -> Q /\ P`. *)
Theorem and_commut : forall P Q : Prop,
  P /\ Q -> Q /\ P.
Proof. Admitted.


(** Úloha 14 ★  
    Dokážte asociativitu konjunkcie: `P /\ (Q /\ R) -> (P /\ Q) /\ R`. *)
Theorem and_assoc : forall P Q R : Prop,
  P /\ (Q /\ R) -> (P /\ Q) /\ R.
Proof. Admitted.


(** Úloha 15 ★  
    Dokážte, že ak `n * m = 0`, potom `n = 0 \/ m = 0`. *)
Lemma mult_is_O :
  forall n m, n * m = 0 -> n = 0 \/ m = 0.
Proof. Admitted.


(** Úloha 16 ★  
    Dokážte komutatívnosť disjunkcie: `P \/ Q -> Q \/ P`. *)
Theorem or_commut : forall P Q : Prop,
  P \/ Q  -> Q \/ P.
Proof. Admitted.


(** Úloha 17 ★  
    Dokážte kontrapozíciu: `(P -> Q) -> (~Q -> ~P)`. *)
Theorem contrapositive : forall (P Q : Prop),
  (P -> Q) -> (~Q -> ~P).
Proof. Admitted.


(** Úloha 18 ★  
    Dokážte, že nemožno mať `P` aj `~P` zároveň: `~ (P /\ ~P)`. *)
Theorem not_both_true_and_false : forall P : Prop,
  ~ (P /\ ~P).
Proof. Admitted.


(** Úloha 19 ★  
    Dokážte De Morganov zákon: `~ (P \/ Q) -> ~P /\ ~Q`. *)
Theorem de_morgan_not_or : forall (P Q : Prop),
    ~ (P \/ Q) -> ~P /\ ~Q.
Proof. Admitted.


(** Úloha 20 ★  
    Dokážte, že neplatí `forall n, S (pred n) = n`. *)
Lemma not_S_pred_n : ~(forall n : nat, S (pred n) = n).
Proof. Admitted.


(** Úloha 21 ★  
    Dokážte, že prázdny zoznam nie je tvaru `x :: xs`. *)
Theorem nil_is_not_cons : forall X (x : X) (xs : list X), ~ (nil = x :: xs).
Proof. Admitted.


(** Úloha 22 ★  
    Dokážte, že ekvivalencia je reflexívna: `P <-> P`. *)
Theorem iff_refl : forall P : Prop,
  P <-> P.
Proof. Admitted.


(** Úloha 23 ★  
    Dokážte tranzitivitu ekvivalencie:  
    ak `P <-> Q` a `Q <-> R`, potom `P <-> R`. *)
Theorem iff_trans : forall P Q R : Prop,
  (P <-> Q) -> (Q <-> R) -> (P <-> R).
Proof. Admitted.


(** Úloha 24 ★  
    Dokážte distribučný zákon: `P \/ (Q /\ R) <-> (P \/ Q) /\ (P \/ R)`. *)
Theorem or_distributes_over_and : forall P Q R : Prop,
  P \/ (Q /\ R) <-> (P \/ Q) /\ (P \/ R).
Proof. Admitted.


(** Úloha 25 ★  
    Dokážte, že ak `P x` platí pre všetky `x`, tak neexistuje `x`, pre ktorý `~P x`. *)
Theorem dist_not_exists : forall (X:Type) (P : X -> Prop),
  (forall x, P x) -> ~ (exists x, ~ P x).
Proof. Admitted.


(** Úloha 26 ★  
    Dokážte, že existencia disjunkcie sa rozdeľuje:  
    `(exists x, P x \/ Q x) <-> (exists x, P x) \/ (exists x, Q x)`. *)
Theorem dist_exists_or : forall (X:Type) (P Q : X -> Prop),
  (exists x, P x \/ Q x) <-> (exists x, P x) \/ (exists x, Q x).
Proof. Admitted.


(** Úloha 27 ★  
    Dokážte, že ak `n <=? m = true`, potom existuje `x` s `m = n + x`. *)
Theorem leb_plus_exists : forall n m, n <=? m = true -> exists x, m = n+x.
Proof. Admitted.


(** Úloha 28 ★  
    Dokážte, že ak `m = n + x` pre nejaké `x`, potom `n <=? m = true`. *)
Theorem plus_exists_leb : forall n m, (exists x, m = n+x) -> n <=? m = true.
Proof. Admitted.

