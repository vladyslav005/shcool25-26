
(* ================================================================= *)
(** ** Zadanie: STLC s aritmetikou *)

(** Jednoducho typovaný λ-kalkul (STLC),
    rozšírime ho o konkrétny základný typ čísel a niekoľko
    konštánt a primitívnych operátorov. *)

Require Import Stdlib.Bool.Bool.
Require Import Stdlib.Arith.PeanoNat.
Require Import Init.Nat.
Require Import Stdlib.Lists.List.
Import ListNotations.
Local Open Scope nat_scope.
Local Open Scope list_scope.
From Coq Require Import String.
Open Scope string_scope.
Module STLCArith.

(** K typom pridáme základný typ prirodzených čísel (a pre stručnosť
    odstránime booleovské typy). *)

Inductive ty : Type :=
  | Ty_Arrow : ty -> ty -> ty
  | Ty_Nat  : ty.

(** K termom pridáme konštanty prirodzených čísel, spolu s
    funkciami successor, predecessor, násobenie a testovaním nulovosti. *)

Inductive tm : Type :=
  | tm_var : string -> tm
  | tm_app : tm -> tm -> tm
  | tm_abs : string -> ty -> tm -> tm
  | tm_const  : nat -> tm
  | tm_succ : tm -> tm
  | tm_pred : tm -> tm
  | tm_mult : tm -> tm -> tm
  | tm_if0 : tm -> tm -> tm -> tm.

(* ================================================================= *)
(** * STLC rozšírený o aritmetiku *)
(** Termy:
       t ::= x                      (premenná)
           | \x:T,t                 (λ-abstrakcia)
           | t t                    (aplikácia)
           | n                      (konštanta prirodzeného čísla)
           | succ t                 (nasledovník)
           | pred t                 (predchodca)
           | t * t                  (násobenie)
           | if0 t then t else t    (podmienený výraz testujúci nulu)
   Typy:
       T ::= Nat | T -> T

   - T -> T - typový konštruktor funkcie.
   - Nat - základný typ prirodzených čísel.
   - Konštanty a operácie: n, succ, pred, *, if0. *)


Declare Scope stlc_scope.
Delimit Scope stlc_scope with stlc.
Open Scope stlc_scope.

Declare Custom Entry stlc_ty.
Declare Custom Entry stlc_tm.

(** Konkrétna syntax *)
Notation "x" := x (in custom stlc_ty at level 0, x global) 
: stlc_scope.

Notation "<{{ x }}>" := x (x custom stlc_ty).

Notation "( t )" := 
t (in custom stlc_ty at level 0, t custom stlc_ty) 
: stlc_scope.
Notation "S -> T" := 
(Ty_Arrow S T) (in custom stlc_ty at level 99, right associativity) 
: stlc_scope.

Notation "$( t )" := 
t (in custom stlc_ty at level 0, t constr) : stlc_scope.


Notation "$( x )" := x (in custom stlc_tm at level 0, x constr, only parsing) : stlc_scope.
Notation "x" := x (in custom stlc_tm at level 0, x constr at level 0) : stlc_scope.
Notation "<{ e }>" := e (e custom stlc_tm at level 200) : stlc_scope.
Notation "( x )" := x (in custom stlc_tm at level 0, x custom stlc_tm) : stlc_scope.

Notation "x y" := (tm_app x y) (in custom stlc_tm at level 10, left associativity) : stlc_scope.
Notation "\ x : t , y" :=
  (tm_abs x t y) (in custom stlc_tm at level 200, x global,
                     t custom stlc_ty,
                     y custom stlc_tm at level 200,
                     left associativity).
Coercion tm_var : string >-> tm.
Arguments tm_var _%_string.

Notation "'Nat'" := Ty_Nat (in custom stlc_ty at level 0).
Notation "'succ' x" := (tm_succ x) (in custom stlc_tm at level 10,
                                     x custom stlc_tm at level 0) : stlc_scope.
Notation "'pred' x" := (tm_pred x) (in custom stlc_tm at level 10,
                                     x custom stlc_tm at level 0) : stlc_scope.
Notation "x * y" := (tm_mult x y) (in custom stlc_tm at level 95,
                                      right associativity) : stlc_scope.
Notation "'if0' x 'then' y 'else' z" :=
  (tm_if0 x y z) (in custom stlc_tm at level 0,
                    x custom stlc_tm at level 0,
                    y custom stlc_tm at level 0,
                    z custom stlc_tm at level 0) : stlc_scope.

Coercion tm_const : nat >-> tm.

Definition x : string := "x".
Definition y : string := "y".
Definition z : string := "z".
Hint Unfold x : core.
Hint Unfold y : core.
Hint Unfold z : core.


(** Vašou úlohou dokončiť formalizáciu
definície a vlastností STLC rozšíreného o aritmetiku.

Konkrétne:
Vyplňte základné definície pre STLCArith, začínajúc pravidlami
a termami, ktoré sú rovnaké ako v STLC. Potom dokážte kľúčové
lemy a vety, ktoré poskytujeme. Budete musieť definovať a dokázať
pomocné lemy, ako predtým.

Bude potrebné doplniť aj "Reserved Notation", "Notation"
a "Hint Constructors".

Nápoveda: Ak sa vám zobrazí chyba "STLC.tm" namiesto termu "tm",
Rocq používa starú notáciu (napr. pre subst) namiesto novej
pre STLCArith, takže musíte prepísať starú notáciu predtým,
než ju budete môcť použiť.

Uistite sa, že Rocq akceptuje celý súbor pred odovzdaním. 
*)


(** ----------------------------------------------- **)
(** Úloha 1 ★ Doplnte definíciu substitúcie. *)

Reserved Notation "'[' x ':=' s ']' t"
  (in custom stlc_tm at level 5, x global,
   s custom stlc_tm, t custom stlc_tm at next level,
   right associativity).

Fixpoint subst (x : string) (s : tm) (t : tm) : tm :=
  match t with
  | tm_var y =>
      if String.eqb x y then s else t
  | tm_abs y T t1 =>
      if String.eqb x y then t else tm_abs y T (subst x s t1)
  | tm_app t1 t2 =>
      tm_app (subst x s t1) (subst x s t2)
  | tm_const n =>
      tm_const n
  | tm_succ t1 =>
      tm_succ (subst x s t1)
  | tm_pred t1 =>
      tm_pred (subst x s t1)
  | tm_mult t1 t2 =>
      tm_mult (subst x s t1) (subst x s t2)
  | tm_if0 t1 t2 t3 =>
      tm_if0 (subst x s t1) (subst x s t2) (subst x s t3)
  end

where "'[' x ':=' s ']' t" := (subst x s t) (in custom stlc_tm).
(** 
Po definícii funkcie je potrebné odstrániť bodku na konci 
a pridať nasledujúci riadok

where "'[' x ':=' s ']' t" := (subst x s t) (v custom stlc_tm).
*)

(** ----------------------------------------------- **)
(** Úloha 2 ★ Doplnte definíciu hodnoty. *)

Inductive value : tm -> Prop :=
| v_abs   : forall x T t, value <{\x:T, t}>
| v_const : forall n,    value (tm_const n).


Hint Constructors value : core.


Reserved Notation "t '-->' t'" (at level 40).

(** ----------------------------------------------- **)
(** Úloha 3 ★ Doplnte definíciu štrukturálnej operačnej sémantiky . *)

Inductive step : tm -> tm -> Prop :=
(* β-reduction *)
  | ST_AppAbs : forall x T t1 v2,
      value v2 ->
      <{ (\x:$(T), t1) v2 }> --> <{ [x:=v2] t1 }>

  (* application congruence *)
  | ST_App1 : forall t1 t1' t2,
      t1 --> t1' ->
      <{ t1 t2 }> --> <{ t1' t2 }>
  | ST_App2 : forall v1 t2 t2',
      value v1 ->
      t2 --> t2' ->
      <{ v1 t2 }> --> <{ v1 t2' }>

  (* succ *)
  | ST_Succ : forall t1 t1',
      t1 --> t1' ->
      <{ succ t1 }> --> <{ succ t1' }>
  | ST_SuccConst : forall (n : nat),
      <{ succ n }> --> (S n)


  (* pred *)
  | ST_Pred : forall t1 t1',
      t1 --> t1' ->
      <{ pred t1 }> --> <{ pred t1' }>
  | ST_PredZero :
      <{ pred 0 }> --> 0
  | ST_PredSucc : forall (n : nat),
      <{ pred (succ n) }> --> n

  (* multiplication *)
  | ST_Mult1 : forall t1 t1' t2,
      t1 --> t1' ->
      <{ t1 * t2 }> --> <{ t1' * t2 }>
  | ST_Mult2 : forall v1 t2 t2',
      value v1 -> t2 --> t2' ->
      <{ v1 * t2 }> --> <{ v1 * t2' }>
  | ST_MultConst : forall (n m : nat),
      <{ n * m }> --> (n * m)

  (* if0 *)
  | ST_If0 : forall t1 t1' t2 t3,
      t1 --> t1' ->
      <{ if0 t1 then t2 else t3 }> --> <{ if0 t1' then t2 else t3 }>
  | ST_If0Zero : forall t2 t3,
      <{ if0 0 then t2 else t3 }> --> t2
  | ST_If0Succ : forall (n : nat) t2 t3,
      <{ if0 (succ n) then t2 else t3 }> --> t3

where "t '-->' t'" := (step t t').

Inductive multistep : tm -> tm -> Prop :=
  | multi_refl : forall t, multistep t t  
  | multi_tran : forall t1 t2 t3,
      step t1 t2 ->  
      multistep t2 t3 ->
      multistep t1 t3.
Notation "t1 '-->*' t2" := (multistep t1 t2) (at level 40).

Hint Constructors step : core.

(* Príklad *)
Example Nat_step_example : exists t,
<{(\x: Nat, \y: Nat, x * y ) $(3) $(2) }> -->* t.
Proof.
  exists 6.
  eapply multi_tran.
  - 
    apply ST_App1.
    apply ST_AppAbs. constructor.
  - eapply multi_tran.
    + 
      apply ST_AppAbs. constructor.
    + eapply multi_tran.
      * 
        apply ST_MultConst.
      * 
        apply multi_refl.
Qed.

(* Typový systém *)
Definition total_map (A : Type) := string -> A.

Definition t_empty {A : Type} (v : A) : total_map A :=
  (fun _ => v).

Definition t_update {A : Type} (m : total_map A)
                    (x : string) (v : A) :=
  fun x' => if String.eqb x x' then v else m x'.

Notation "'_' '!->' v" := (t_empty v)
  (at level 100, right associativity).
Notation "x '!->' v ';' m" := 
        (t_update m x v)
        (at level 100, x constr, right associativity).

Definition partial_map (A : Type) := total_map (option A).

Definition empty {A : Type} : partial_map A :=
  t_empty None.

Definition update {A : Type} (m : partial_map A)
           (x : string) (v : A) :=
  (x !-> Some v ; m).

Notation "x '|->' v ';' m" := (update m x v)
  (at level 0, x constr, v at level 200, right associativity).

Notation "x '|->' v" := (update empty x v)
  (at level 0, x constr, v at level 200).

Definition includedin {A : Type} (m m' : partial_map A) :=
  forall x v, m x = Some v -> m' x = Some v.

Definition context := partial_map ty.

Reserved Notation "<{ Gamma '|--' t '\in' T }>"
(at level 0, Gamma custom stlc_tm at level 200, 
t custom stlc_tm, T custom stlc_ty).

(** ----------------------------------------------- **)
(** Úloha 4 ★ Doplnte definíciu substitúcie. *)

Inductive has_type : context -> tm -> ty -> Prop :=
  | T_Var : forall Gamma x T1,
      Gamma x = Some T1 ->
      <{ Gamma |-- x \in T1 }>
  | T_Abs : forall Gamma x T1 T2 t1,
      <{ x |-> T2 ; Gamma |-- t1 \in T1 }> ->
      <{ Gamma |-- \x:T2, t1 \in T2 -> T1 }>
  | T_App : forall T1 T2 Gamma t1 t2,
      <{ Gamma |-- t1 \in T2 -> T1 }> ->
      <{ Gamma |-- t2 \in T2 }> ->
      <{ Gamma |-- t1 t2 \in T1 }>

(** DOPLNIT *)
 | T_Const : forall Gamma n,
      <{ Gamma |-- $(n) \in Nat }>

  | T_Succ : forall Gamma t1,
      <{ Gamma |-- t1 \in Nat }> ->
      <{ Gamma |-- succ t1 \in Nat }>

  | T_Pred : forall Gamma t1,
      <{ Gamma |-- t1 \in Nat }> ->
      <{ Gamma |-- pred t1 \in Nat }>

  | T_Mult : forall Gamma t1 t2,
      <{ Gamma |-- t1 \in Nat }> ->
      <{ Gamma |-- t2 \in Nat }> ->
      <{ Gamma |-- t1 * t2 \in Nat }>

  | T_If0 : forall Gamma t1 t2 t3 T,
      <{ Gamma |-- t1 \in Nat }> ->
      <{ Gamma |-- t2 \in T }> ->
      <{ Gamma |-- t3 \in T }> ->
      <{ Gamma |-- if0 t1 then t2 else t3 \in T }>

where "<{ Gamma '|--' t '\in' T }>" := 
  (has_type Gamma t T) : stlc_scope.

Hint Constructors has_type : core.
Hint Constructors has_type : core.

(* Príklad *)
Example Nat_typing_example :
   <{ empty |-- ( \x: Nat, \y: Nat, x * y ) $(3) $(2) \in Nat }>.
Proof.
  eapply T_App.
  - 
    eapply T_App.
    + 
      apply T_Abs.
      apply T_Abs.
      apply T_Mult.
      * 
        apply T_Var.
        unfold update, t_update, x, y; simpl. reflexivity.
      * 
        apply T_Var.
        unfold update, t_update, x, y; simpl. reflexivity.
    + 
      apply T_Const.
  - 
    apply T_Const.
Qed.



(* ================================================================= *)
(** ** Vety *)

(* ================================================================= *)

Lemma t_update_eq : forall (A : Type) (m : total_map A) x v,
  (x !-> v ; m) x = v.
Proof.
 intros A m x v. unfold t_update.
  destruct (String.eqb x x) eqn:E; [reflexivity|].
  (* druhá vetva je nemožná: x <> x *)
  apply String.eqb_neq in E; congruence.
Qed.
(** [] *)

Theorem t_update_neq : forall (A : Type) (m : total_map A) x1 x2 v,
  x1 <> x2 ->
  (x1 !-> v ; m) x2 = m x2.
Proof.
  intros A m x1 x2 v Hneq.
  unfold t_update.
  destruct (String.eqb x1 x2) eqn:E.
  - apply String.eqb_eq in E; contradiction.
  - reflexivity.
Qed.


Lemma update_eq : forall (A : Type) (m : partial_map A) x v,
  (x |-> v ; m) x = Some v.
Proof.
  intros. unfold update. rewrite t_update_eq.
  reflexivity.
Qed.

Theorem update_neq : forall (A : Type) (m : partial_map A) x1 x2 v,
  x2 <> x1 ->
  (x2 |-> v ; m) x1 = m x1.
Proof.
  intros A m x1 x2 v H.
  unfold update. rewrite t_update_neq.
  - reflexivity.
  - apply H.
Qed.

Lemma includedin_update : forall (A : Type) (m m' : partial_map A)
                                 (x : string) (vx : A),
  includedin m m' ->
  includedin (x |-> vx ; m) (x |-> vx ; m').
Proof.
  unfold includedin.
  intros A m m' x vx H.
  intros y vy.
  destruct (eqb_spec x y) as [Hxy | Hxy].
  - rewrite Hxy.
    rewrite update_eq. rewrite update_eq. intro H1. apply H1.
  - rewrite update_neq.
    + rewrite update_neq.
      * apply H.
      * apply Hxy.
    + apply Hxy.
Qed.
(* ================================================================= *)


(** ----------------------------------------------- **)
(** Úloha 5 ★ Dokážte nasledujúcu vetu. *)

Lemma weakening : forall Gamma Gamma' t T,
     includedin Gamma Gamma' ->
     <{ Gamma  |-- t \in T }> ->
     <{ Gamma' |-- t \in T }>.
Proof. 
  intros Gamma Gamma' t T H Ht.
  generalize dependent Gamma'.
  induction Ht; eauto using includedin_update.
Qed.




(** ----------------------------------------------- **)
(** Úloha 6 ★ Dokážte nasledujúcu vetu. *)

(* ================================================================= *)
From Coq Require Import Logic.FunctionalExtensionality.
Lemma t_update_shadow : forall (A : Type) (m : total_map A) x v1 v2,
  (x !-> v2 ; x !-> v1 ; m) = (x !-> v2 ; m).
Proof.
 intros A m x v1 v2.
  unfold t_update.
  apply functional_extensionality; intro x'.

  destruct (String.eqb x x') eqn:E; reflexivity.
Qed.

Lemma includedin_empty : forall (A:Type) (m: partial_map A),
  includedin (@empty A) m.
Proof.
  unfold includedin; intros A m x v H.
  unfold empty in H. simpl in H. discriminate.
Qed.

Lemma weakening_empty : forall Gamma t T,
     <{ empty |-- t \in T }> ->
     <{ Gamma |-- t \in T }>.
Proof.
  intros Gamma t T Ht.
  eapply weakening; [apply includedin_empty | exact Ht].
Qed.

Lemma update_shadow : forall (A : Type) (m : partial_map A) x v1 v2,
  (x |-> v2 ; x |-> v1 ; m) = (x |-> v2 ; m).
Proof.
  intros A m x v1 v2. unfold update. rewrite t_update_shadow.
  reflexivity.
Qed.

Theorem t_update_permute : forall (A : Type) (m : total_map A)
                                  v1 v2 x1 x2,
  x2 <> x1 ->
  (x1 !-> v1 ; x2 !-> v2 ; m)
  =
  (x2 !-> v2 ; x1 !-> v1 ; m).
Proof.
  intros A m v1 v2 x1 x2 Hneq.
  apply functional_extensionality; intro x.
  unfold t_update.
  destruct (String.eqb x1 x) eqn:E1;
  destruct (String.eqb x2 x) eqn:E2; simpl; try reflexivity.
  apply String.eqb_eq in E1.
  apply String.eqb_eq in E2.
  exfalso.
  apply Hneq.
  rewrite E2. symmetry. exact E1.
Qed.

Theorem update_permute : forall (A : Type) (m : partial_map A)
                                x1 x2 v1 v2,
  x2 <> x1 ->
  (x1 |-> v1 ; x2 |-> v2 ; m) = (x2 |-> v2 ; x1 |-> v1 ; m).
Proof.
  intros A m x1 x2 v1 v2. unfold update.
  apply t_update_permute.
Qed.



Lemma substitution_preserves_typing : forall Gamma x U t v T,
  <{ x |-> U ; Gamma |-- t \in T }> ->
  <{ empty |-- v \in U }>  ->
  <{ Gamma |-- [x:=v]t \in T }>.
Proof.
  intros Gamma x U t v T Ht Hv.
  generalize dependent Gamma. generalize dependent T.
  induction t; intros T Gamma H;
  (* v každom poddôkaze potrebujeme inverziu H *)
    inversion H; clear H; subst; simpl; eauto.
  - (* var *)
    rename s into y. destruct (eqb_spec x y); subst. 
    + (* x=y *)
      rewrite update_eq in H2.
      injection H2 as H2; subst.
      apply weakening_empty. assumption.
    + (* x<>y *)
      apply T_Var. rewrite update_neq in H2. 
      -- auto. 
      -- auto. 
  - (* abs *)
    rename s into y, t into S.
    destruct (eqb_spec x y); subst; apply T_Abs.
    + (* x=y *)
      rewrite update_shadow in H5. assumption.
    + (* x<>y *)
      apply IHt.
      rewrite update_permute; auto.
Qed.


(* ================================================================= *)

(* Zachovanie typu (Preservation) *)
(* Nápoveda: Bude potrebné definovať a dokázať tie isté pomocné vety, 
  ktoré sú dokazáné v STLC + Bool. *)
Theorem preservation : forall t t' T,
  <{ empty |-- t \in T }> ->
  t --> t'  ->
  <{ empty |-- t' \in T }>.
Proof with eauto. 
  intros t t' T HT. generalize dependent t'.
  remember empty as Gamma.
  induction HT;
       intros t' HE; subst;
       try solve [inversion HE; subst; auto].
  - (* T_App *)
    inversion HE; subst...
    (* Väčšina prípadov nasleduje priamo z indukcie,
      a [eauto] ich automaticky vyrieši. *)
    + (* ST_AppAbs *)
      apply substitution_preserves_typing with T2. 
      -- inversion HT1. subst. apply H1.
      -- assumption. 
Qed.



(** ----------------------------------------------- **)
(** Úloha 7 ★ Dokážte nasledujúcu vetu. *)
(* ================================================================= *)

(* ================================================================= *)
(* Progress *)
Theorem progress : forall t T,
  <{ empty |-- t \in T }> ->
  value t \/ exists t', t --> t'.
Proof with eauto.  
Admitted.


End STLCArith.
